"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import nebius.common.v1.metadata_pb2
import nebius.mk8s.v1.instance_template_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class NodeGroup(google.protobuf.message.Message):
    """NodeGroup represents Kubernetes node pool"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    METADATA_FIELD_NUMBER: builtins.int
    SPEC_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    @property
    def metadata(self) -> nebius.common.v1.metadata_pb2.ResourceMetadata:
        """the parent_id is an ID of Cluster"""

    @property
    def spec(self) -> global___NodeGroupSpec: ...
    @property
    def status(self) -> global___NodeGroupStatus: ...
    def __init__(
        self,
        *,
        metadata: nebius.common.v1.metadata_pb2.ResourceMetadata | None = ...,
        spec: global___NodeGroupSpec | None = ...,
        status: global___NodeGroupStatus | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["metadata", b"metadata", "spec", b"spec", "status", b"status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["metadata", b"metadata", "spec", b"spec", "status", b"status"]) -> None: ...

global___NodeGroup = NodeGroup

@typing.final
class NodeGroupSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VERSION_FIELD_NUMBER: builtins.int
    FIXED_NODE_COUNT_FIELD_NUMBER: builtins.int
    TEMPLATE_FIELD_NUMBER: builtins.int
    STRATEGY_FIELD_NUMBER: builtins.int
    version: builtins.str
    """Version is desired Kubernetes version of the cluster. For now only acceptable format is
    `MAJOR.MINOR` like "1.30". Option for patch version update will be added later.
    By default the cluster control plane MAJOR.MINOR version will be used.
    """
    fixed_node_count: builtins.int
    """number of nodes in the group"""
    @property
    def template(self) -> global___NodeTemplate: ...
    @property
    def strategy(self) -> global___NodeGroupDeploymentStrategy: ...
    def __init__(
        self,
        *,
        version: builtins.str = ...,
        fixed_node_count: builtins.int = ...,
        template: global___NodeTemplate | None = ...,
        strategy: global___NodeGroupDeploymentStrategy | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["fixed_node_count", b"fixed_node_count", "size", b"size", "strategy", b"strategy", "template", b"template"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["fixed_node_count", b"fixed_node_count", "size", b"size", "strategy", b"strategy", "template", b"template", "version", b"version"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["size", b"size"]) -> typing.Literal["fixed_node_count"] | None: ...

global___NodeGroupSpec = NodeGroupSpec

@typing.final
class NodeTemplate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    METADATA_FIELD_NUMBER: builtins.int
    TAINTS_FIELD_NUMBER: builtins.int
    RESOURCES_FIELD_NUMBER: builtins.int
    BOOT_DISK_FIELD_NUMBER: builtins.int
    GPU_CLUSTER_FIELD_NUMBER: builtins.int
    NETWORK_INTERFACES_FIELD_NUMBER: builtins.int
    FILESYSTEMS_FIELD_NUMBER: builtins.int
    CLOUD_INIT_USER_DATA_FIELD_NUMBER: builtins.int
    SERVICE_ACCOUNT_ID_FIELD_NUMBER: builtins.int
    cloud_init_user_data: builtins.str
    """cloud-init user-data. Must contain at least one SSH key."""
    service_account_id: builtins.str
    """the Nebius service account whose credentials will be available on the nodes of the group.
    With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
    This service account is also used to make requests to container registry.

    `resource.serviceaccount.issueAccessToken` permission is required to use this field.
    """
    @property
    def metadata(self) -> global___NodeMetadataTemplate: ...
    @property
    def taints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NodeTaint]: ...
    @property
    def resources(self) -> nebius.mk8s.v1.instance_template_pb2.ResourcesSpec: ...
    @property
    def boot_disk(self) -> nebius.mk8s.v1.instance_template_pb2.DiskSpec: ...
    @property
    def gpu_cluster(self) -> global___GpuClusterSpec: ...
    @property
    def network_interfaces(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NetworkInterfaceTemplate]: ...
    @property
    def filesystems(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AttachedFilesystemSpec]: ...
    def __init__(
        self,
        *,
        metadata: global___NodeMetadataTemplate | None = ...,
        taints: collections.abc.Iterable[global___NodeTaint] | None = ...,
        resources: nebius.mk8s.v1.instance_template_pb2.ResourcesSpec | None = ...,
        boot_disk: nebius.mk8s.v1.instance_template_pb2.DiskSpec | None = ...,
        gpu_cluster: global___GpuClusterSpec | None = ...,
        network_interfaces: collections.abc.Iterable[global___NetworkInterfaceTemplate] | None = ...,
        filesystems: collections.abc.Iterable[global___AttachedFilesystemSpec] | None = ...,
        cloud_init_user_data: builtins.str = ...,
        service_account_id: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["boot_disk", b"boot_disk", "gpu_cluster", b"gpu_cluster", "metadata", b"metadata", "resources", b"resources"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["boot_disk", b"boot_disk", "cloud_init_user_data", b"cloud_init_user_data", "filesystems", b"filesystems", "gpu_cluster", b"gpu_cluster", "metadata", b"metadata", "network_interfaces", b"network_interfaces", "resources", b"resources", "service_account_id", b"service_account_id", "taints", b"taints"]) -> None: ...

global___NodeTemplate = NodeTemplate

@typing.final
class NodeMetadataTemplate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    LABELS_FIELD_NUMBER: builtins.int
    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Labels will be propagated into nodes metadata.
        System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
        On update labels they will not be updated in nodes right away, only on node group update.
        """

    def __init__(
        self,
        *,
        labels: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["labels", b"labels"]) -> None: ...

global___NodeMetadataTemplate = NodeMetadataTemplate

@typing.final
class GpuClusterSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    id: builtins.str
    def __init__(
        self,
        *,
        id: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["id", b"id"]) -> None: ...

global___GpuClusterSpec = GpuClusterSpec

@typing.final
class NetworkInterfaceTemplate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PUBLIC_IP_ADDRESS_FIELD_NUMBER: builtins.int
    SUBNET_ID_FIELD_NUMBER: builtins.int
    subnet_id: builtins.str
    """Subnet ID that will be attached to a node cloud intstance network interface.
    By default control plane subnet_id used.
    Subnet should be located in the same network with control plane and have same parent ID as cluster.
    """
    @property
    def public_ip_address(self) -> global___PublicIPAddress:
        """Public IPv4 address associated with the interface."""

    def __init__(
        self,
        *,
        public_ip_address: global___PublicIPAddress | None = ...,
        subnet_id: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["public_ip_address", b"public_ip_address"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["public_ip_address", b"public_ip_address", "subnet_id", b"subnet_id"]) -> None: ...

global___NetworkInterfaceTemplate = NetworkInterfaceTemplate

@typing.final
class PublicIPAddress(google.protobuf.message.Message):
    """Describes a public IP address."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___PublicIPAddress = PublicIPAddress

@typing.final
class AttachedFilesystemSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _AttachMode:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _AttachModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[AttachedFilesystemSpec._AttachMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNSPECIFIED: AttachedFilesystemSpec._AttachMode.ValueType  # 0
        READ_ONLY: AttachedFilesystemSpec._AttachMode.ValueType  # 1
        READ_WRITE: AttachedFilesystemSpec._AttachMode.ValueType  # 2

    class AttachMode(_AttachMode, metaclass=_AttachModeEnumTypeWrapper): ...
    UNSPECIFIED: AttachedFilesystemSpec.AttachMode.ValueType  # 0
    READ_ONLY: AttachedFilesystemSpec.AttachMode.ValueType  # 1
    READ_WRITE: AttachedFilesystemSpec.AttachMode.ValueType  # 2

    ATTACH_MODE_FIELD_NUMBER: builtins.int
    MOUNT_TAG_FIELD_NUMBER: builtins.int
    EXISTING_FILESYSTEM_FIELD_NUMBER: builtins.int
    attach_mode: global___AttachedFilesystemSpec.AttachMode.ValueType
    mount_tag: builtins.str
    """Specifies the user-defined identifier, allowing to use it as a device in mount command."""
    @property
    def existing_filesystem(self) -> global___ExistingFilesystem: ...
    def __init__(
        self,
        *,
        attach_mode: global___AttachedFilesystemSpec.AttachMode.ValueType = ...,
        mount_tag: builtins.str = ...,
        existing_filesystem: global___ExistingFilesystem | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["existing_filesystem", b"existing_filesystem", "type", b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["attach_mode", b"attach_mode", "existing_filesystem", b"existing_filesystem", "mount_tag", b"mount_tag", "type", b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["type", b"type"]) -> typing.Literal["existing_filesystem"] | None: ...

global___AttachedFilesystemSpec = AttachedFilesystemSpec

@typing.final
class ExistingFilesystem(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    id: builtins.str
    def __init__(
        self,
        *,
        id: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["id", b"id"]) -> None: ...

global___ExistingFilesystem = ExistingFilesystem

@typing.final
class NodeTaint(google.protobuf.message.Message):
    """See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Effect:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _EffectEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NodeTaint._Effect.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        EFFECT_UNSPECIFIED: NodeTaint._Effect.ValueType  # 0
        NO_EXECUTE: NodeTaint._Effect.ValueType  # 1
        NO_SCHEDULE: NodeTaint._Effect.ValueType  # 2
        PREFER_NO_SCHEDULE: NodeTaint._Effect.ValueType  # 3

    class Effect(_Effect, metaclass=_EffectEnumTypeWrapper): ...
    EFFECT_UNSPECIFIED: NodeTaint.Effect.ValueType  # 0
    NO_EXECUTE: NodeTaint.Effect.ValueType  # 1
    NO_SCHEDULE: NodeTaint.Effect.ValueType  # 2
    PREFER_NO_SCHEDULE: NodeTaint.Effect.ValueType  # 3

    KEY_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    EFFECT_FIELD_NUMBER: builtins.int
    key: builtins.str
    value: builtins.str
    effect: global___NodeTaint.Effect.ValueType
    def __init__(
        self,
        *,
        key: builtins.str = ...,
        value: builtins.str = ...,
        effect: global___NodeTaint.Effect.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["effect", b"effect", "key", b"key", "value", b"value"]) -> None: ...

global___NodeTaint = NodeTaint

@typing.final
class NodeGroupDeploymentStrategy(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAX_UNAVAILABLE_FIELD_NUMBER: builtins.int
    MAX_SURGE_FIELD_NUMBER: builtins.int
    DRAIN_TIMEOUT_FIELD_NUMBER: builtins.int
    @property
    def max_unavailable(self) -> global___PercentOrCount:
        """The maximum number of machines that can be unavailable during the update.
        Value can be an absolute number (ex: 5) or a percentage of desired
        machines (ex: 10%).
        Absolute number is calculated from percentage by rounding down.
        This can not be 0 if MaxSurge is 0.
        Defaults to 0.
        Example: when this is set to 30%, the old MachineSet can be scaled
        down to 70% of desired machines immediately when the rolling update
        starts. Once new machines are ready, old MachineSet can be scaled
        down further, followed by scaling up the new MachineSet, ensuring
        that the total number of machines available at all times
        during the update is at least 70% of desired machines.
        """

    @property
    def max_surge(self) -> global___PercentOrCount:
        """The maximum number of machines that can be scheduled above the
        desired number of machines.
        Value can be an absolute number (ex: 5) or a percentage of
        desired machines (ex: 10%).
        This can not be 0 if MaxUnavailable is 0.
        Absolute number is calculated from percentage by rounding up.
        Defaults to 1.
        Example: when this is set to 30%, the new MachineSet can be scaled
        up immediately when the rolling update starts, such that the total
        number of old and new machines do not exceed 130% of desired
        machines. Once old machines have been killed, new MachineSet can
        be scaled up further, ensuring that total number of machines running
        at any time during the update is at most 130% of desired machines.
        """

    @property
    def drain_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """DrainTimeout is the total amount of time that the service will spend on draining a node.
        By default, node can be drained without any time limitations.
        NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """

    def __init__(
        self,
        *,
        max_unavailable: global___PercentOrCount | None = ...,
        max_surge: global___PercentOrCount | None = ...,
        drain_timeout: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["drain_timeout", b"drain_timeout", "max_surge", b"max_surge", "max_unavailable", b"max_unavailable"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["drain_timeout", b"drain_timeout", "max_surge", b"max_surge", "max_unavailable", b"max_unavailable"]) -> None: ...

global___NodeGroupDeploymentStrategy = NodeGroupDeploymentStrategy

@typing.final
class PercentOrCount(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PERCENT_FIELD_NUMBER: builtins.int
    COUNT_FIELD_NUMBER: builtins.int
    percent: builtins.int
    count: builtins.int
    def __init__(
        self,
        *,
        percent: builtins.int = ...,
        count: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["count", b"count", "percent", b"percent", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["count", b"count", "percent", b"percent", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["value", b"value"]) -> typing.Literal["percent", "count"] | None: ...

global___PercentOrCount = PercentOrCount

@typing.final
class NodeGroupStatus(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _State:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[NodeGroupStatus._State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        STATE_UNSPECIFIED: NodeGroupStatus._State.ValueType  # 0
        PROVISIONING: NodeGroupStatus._State.ValueType  # 1
        RUNNING: NodeGroupStatus._State.ValueType  # 2
        DELETING: NodeGroupStatus._State.ValueType  # 3

    class State(_State, metaclass=_StateEnumTypeWrapper): ...
    STATE_UNSPECIFIED: NodeGroupStatus.State.ValueType  # 0
    PROVISIONING: NodeGroupStatus.State.ValueType  # 1
    RUNNING: NodeGroupStatus.State.ValueType  # 2
    DELETING: NodeGroupStatus.State.ValueType  # 3

    STATE_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    TARGET_NODE_COUNT_FIELD_NUMBER: builtins.int
    NODE_COUNT_FIELD_NUMBER: builtins.int
    OUTDATED_NODE_COUNT_FIELD_NUMBER: builtins.int
    READY_NODE_COUNT_FIELD_NUMBER: builtins.int
    RECONCILING_FIELD_NUMBER: builtins.int
    state: global___NodeGroupStatus.State.ValueType
    version: builtins.str
    """Version have format `MAJOR.MINOR.PATCH-nebius-node.n` like "1.30.0-nebius-node.10"."""
    target_node_count: builtins.int
    """Desired total number of nodes that should be in the node group.
    It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
    """
    node_count: builtins.int
    """Total number of nodes that are currently in the node group.
    Both ready and not ready nodes are counted.
    """
    outdated_node_count: builtins.int
    """Total number of nodes that has outdated node configuration.
    These nodes will be replaced by new nodes with up-to-date configuration.
    """
    ready_node_count: builtins.int
    """Total number of nodes that successfully joined the cluster and are ready to serve workloads.
    Both outdated and up-to-date nodes are counted.
    """
    reconciling: builtins.bool
    """Show that changes are in flight"""
    def __init__(
        self,
        *,
        state: global___NodeGroupStatus.State.ValueType = ...,
        version: builtins.str = ...,
        target_node_count: builtins.int = ...,
        node_count: builtins.int = ...,
        outdated_node_count: builtins.int = ...,
        ready_node_count: builtins.int = ...,
        reconciling: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["node_count", b"node_count", "outdated_node_count", b"outdated_node_count", "ready_node_count", b"ready_node_count", "reconciling", b"reconciling", "state", b"state", "target_node_count", b"target_node_count", "version", b"version"]) -> None: ...

global___NodeGroupStatus = NodeGroupStatus
